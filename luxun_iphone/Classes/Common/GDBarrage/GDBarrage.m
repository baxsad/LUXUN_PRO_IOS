//
//  GDBarrage.m
//  luxun_iphone
//
//  Created by iURCoder on 4/22/16.
//  Copyright ¬© 2016 iUR. All rights reserved.
//

#import "GDBarrage.h"

#import "GDBarrageCanvas.h"
#import "GDBarrageClock.h"
#import "GDBarrageTrack.h"

#define kTrackSpace 3.0f

@implementation GDBarrageConfiguration

@end

@interface GDBarrage ()

@property (nonatomic, strong) GDBarrageConfiguration *configuration;
@property (nonatomic) CGRect frame;
@property (nonatomic,strong) GDBarrageCanvas * canvas;
@property (nonatomic,strong) NSDate * startTime;
@property (nonatomic,assign) NSTimeInterval pausedDuration;
@property (nonatomic,strong) NSDate * pausedTime;
@property (nonatomic,strong) NSMutableArray * preloadedDescriptors;
@property (nonatomic,strong) GDBarrageClock * clock;
@property (nonatomic,assign) __block NSTimeInterval time;
@property (nonatomic) dispatch_queue_t barrageQueue;
@property (nonatomic,assign) NSInteger fontSzie;
@property (nonatomic,strong) NSMutableArray * tracks;
@property (nonatomic,strong) NSMutableArray * optimalPolicys;
@property (nonatomic,strong) NSMutableArray * trackReckon;

@end

@implementation GDBarrage

- (void)dealloc {
    [_canvas removeFromSuperview];
    _startTime = nil;
    _pausedTime = nil;
    _pausedDuration = 0;
    [_clock stop];
}

- (instancetype)initWithView:(UIView *)view Configuration:(GDBarrageConfiguration *)configuration
{
    self = [self init];
    if (self) {
        _canvas = [[GDBarrageCanvas alloc] init];
        _canvas.frame = view.bounds;
        _canvas.userInteractionEnabled = NO;
        _canvas.backgroundColor = [UIColor clearColor];
        _canvas.clipsToBounds = YES;
        _configuration = configuration;
        _startTime = nil;
        _pausedTime = nil;
        _pausedDuration = 0.00f;
        _barrageQueue = dispatch_queue_create("com.gdbarrage.queue", DISPATCH_QUEUE_CONCURRENT);
        _fontSzie = configuration.fontSize;
        [self clock_init];
        [self track_init];
        [view addSubview:_canvas];
    }
    return self;
}

#pragma mark - ÂøÉË∑≥

- (void)clock_init
{
    _clock = [GDBarrageClock clockWithHandler:^(NSTimeInterval time){
        _time = time;
    }];
}

#pragma mark - ËΩ®ÈÅì

- (void)track_init
{
    __weak typeof(self) weak_self = self;
    
    dispatch_async(dispatch_get_global_queue( DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
        
        __strong typeof(self) strong_self = weak_self;
        
        strong_self.frame = strong_self.canvas.frame;
        CGFloat canvasW = strong_self.frame.size.width;
        CGFloat canvasH = strong_self.frame.size.height;
        CGFloat trackSpace = kTrackSpace;
        NSInteger trackLines = 0;
        CGFloat float_lines = (canvasH - strong_self.fontSzie)/(strong_self.fontSzie + trackSpace) + 1;
        trackLines = floor(float_lines);
        if (float_lines - trackLines != 0)
            trackSpace += (float_lines - trackLines)/(trackLines-1);
        if (!strong_self.tracks) {
            strong_self.tracks = [NSMutableArray array];
            strong_self.optimalPolicys = [NSMutableArray array];
            strong_self.trackReckon = [NSMutableArray array];
        }else{
            [strong_self.tracks removeAllObjects];
            [strong_self.optimalPolicys removeAllObjects];
            [strong_self.trackReckon removeAllObjects];
        }
        for (int i = 0; i < trackLines; i++) {
            GDBarrageTrack * track = [[GDBarrageTrack alloc] init];
            if (i == 0)
                track.trackFrame = CGRectMake(0, i*strong_self.fontSzie, canvasW, strong_self.fontSzie);
            else
                track.trackFrame = CGRectMake(0, i*strong_self.fontSzie + trackSpace*i, canvasW, strong_self.fontSzie);
            track.state = TrackStateFree;
            track.tag = i;
            [strong_self.tracks addObject:track];
        }
        
    });
}

#pragma mark - ËÆ°ÁÆóÂΩìÂâçÊúÄ‰ºòËΩ®ÈÅì

- (GDBarrageTrack *)track_optimal_policy
{
    
    // ÈúÄË¶ÅËÆ°ÁÆóÂá∫ÂΩìÂâçËΩ®ÈÅì‰∏äÊúâÊ≤°ÊúâÂºπÂπïÊ≠£Âú®ËøêË°å
    // ÂºπÂπïÊòØÂê¶ÂÆåÂÖ®Â±ïÁé∞Âú®ËΩ®ÈÅì‰∏ä
    // ÊØè‰∏™ËΩ®ÈÅì‰∏äÊúÄÂêé‰∏Ä‰∏™ÂºπÂπïÂ∞æÈÉ®Ë∑ùÁ¶ªËΩ®ÈÅìÂºÄÂßã‰ΩçÁΩÆÁöÑË∑ùÁ¶ª
    // Ë∑ùÁ¶ªÊúÄÂ§ßÁöÑËΩ®ÈÅì‰∏∫ÊúÄ‰ºòËΩ®ÈÅì
    // Â¶ÇÊûúÊúÄ‰ºòËΩ®ÈÅìÊØîËæÉÂ§öÂàôÈöèÊú∫ÂèñÂÖ∂‰∏≠‰∏Ä‰∏™ÊúÄ‰ºòËΩ®ÈÅì
    // @TODO Â¶ÇÊûúÊ≤°ÊúâÊúÄ‰ºòËΩ®ÈÅìÊÄé‰πàÂäûÔºü
    
    __block GDBarrageTrack * optimal_policy_track;
    [_optimalPolicys removeAllObjects];
    [_trackReckon removeAllObjects];
    [_tracks enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        GDBarrageTrack * track = (GDBarrageTrack *)obj;
        if (!track.lastElement) {
            track.freeSpace = track.trackFrame.size.width;
            [_optimalPolicys addObject:track];
            track.state = TrackStateFree;
        }else{
            [_trackReckon addObject:track];
        }
    }];
    
    // Â¶ÇÊûúÂ≠òÂú®Ëà™ÈÅì‰∏äÊ≤°ÊúâÂºπÂπïÂú®ËøêË°åÁöÑÁä∂ÂÜµÔºåÂ∞±Áõ¥Êé•ÈÄâÂá∫‰∏Ä‰∏™ÊúÄ‰ºòËà™ÈÅìÁªìÊùüËÆ°ÁÆó
    if (_optimalPolicys.count>0) {
        optimal_policy_track = [self sort_track_free_space];
    }
    
    // Â∑≤ÁªèÊâæÂá∫ÊúÄ‰ºòËà™ÈÅì
    if (optimal_policy_track) {
        return optimal_policy_track;
    }
    
    if (_trackReckon.count>0) {
        [_trackReckon enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
            GDBarrageTrack * track = (GDBarrageTrack *)obj;
            
            CALayer *layer = track.lastElement.layer;
            CGRect elementLastElementFrame;
            if (layer.presentationLayer) {
                elementLastElementFrame = ((CALayer *)layer.presentationLayer).frame;
            }else{
                elementLastElementFrame = track.lastElement.frame;
            }
            // È¢ÑÁïô Ôºö ÂºπÂπïÂá∫Áé∞ÊñπÂêë‰∏çÂêåÁÆóÊ≥ïÂ∞Ü‰ºöÊîπÂèò
            CGFloat elementLastElementX = elementLastElementFrame.origin.x;
            CGFloat elementLastElementW = elementLastElementFrame.size.width;
            CGFloat marginBeginOrigin = track.trackFrame.size.width - elementLastElementX - elementLastElementW;
            if (marginBeginOrigin >= 0) {
                track.freeSpace = marginBeginOrigin;
                track.state = TrackStateFree;
                [_optimalPolicys addObject:track];
            }else{
                track.state = TrackStateBusy;
                track.freeSpace = -1;
            }
        }];
    }
    
    // Ëà™ÈÅìÂÖ®ÈÉ®ÁπÅÂøôÔºåÂè™ÊúâÈöèÊú∫Âèñ‰∏Ä‰∏™Ëà™ÈÅìÂá∫Êù•ÂñΩüòî
    
    if (_optimalPolicys.count == 0) {
        int r = arc4random() % [_tracks count];
        optimal_policy_track = [_tracks objectAtIndex:r];
        return optimal_policy_track;
    }
    
    // Â∑≤ÁªèËÆ°ÁÆóÂá∫‰∫ÜÊâÄÂ≠òÂú®ÁöÑÂèØÁî®Ëà™ÈÅì
    
    NSArray *sortArray = [_optimalPolicys sortedArrayUsingComparator:^NSComparisonResult(id obj1, id obj2) {
        
        GDBarrageTrack *track1 = obj1;
        GDBarrageTrack *track2 = obj2;
        
        CALayer *layer1 = track1.lastElement.layer;
        CALayer *layer2 = track2.lastElement.layer;
        
        CGRect elementLastElementFrame1;
        CGRect elementLastElementFrame2;
        
        if (layer1.presentationLayer && layer2.presentationLayer) {
            elementLastElementFrame1 = ((CALayer *)layer1.presentationLayer).frame;
            elementLastElementFrame2 = ((CALayer *)layer2.presentationLayer).frame;
        }else{
            elementLastElementFrame1 = track1.lastElement.frame;
            elementLastElementFrame2 = track2.lastElement.frame;
        }
        
        CGFloat elementLastElementX1 = elementLastElementFrame1.origin.x;
        CGFloat elementLastElementW1 = elementLastElementFrame1.size.width;
        
        CGFloat elementLastElementX2 = elementLastElementFrame2.origin.x;
        CGFloat elementLastElementW2 = elementLastElementFrame2.size.width;
        
        CGFloat space1 = track1.trackFrame.size.width - elementLastElementX1 - elementLastElementW1;
        CGFloat space2 = track2.trackFrame.size.width - elementLastElementX2 - elementLastElementW2;
        
        // Integer tag1 = track1.tag;
        // NSInteger tag2 = track2.tag;
        
        CGFloat v1 = space1;
        CGFloat v2 = space2;
        
        NSComparisonResult result = (v1 <= v2) ? NSOrderedDescending : NSOrderedAscending;
        
        return result;
    }];
    
    optimal_policy_track = sortArray.firstObject;
    
    return optimal_policy_track;
}

#pragma mark - ÊåâÁÖßËà™ÈÅìÂíåÁ©∫Èó≤ÊéíÂ∫è

- (GDBarrageTrack *)sort_track_free_space
{
    int r = arc4random() % [_optimalPolicys count];
    return [_optimalPolicys objectAtIndex:r];
}

#pragma mark - ÂºÄÂßãËøêË°åÂºπÂπï

- (void)start
{
    // Â∞öÊú™ÂêØÂä®,ÂàôÂàùÂßãÂåñÊó∂Èó¥Á≥ªÁªü
    if (!_startTime) {
        _startTime = [NSDate date];
    }
     // ÂºÄÂßãÂâçÂ§Ñ‰∫éÊöÇÂÅúÁä∂ÊÄÅ
    else if(_pausedTime)
    {
        // Â¶ÇÊûúÊöÇÂÅú‰∫ÜËÆ°ÁÆó‰ªéÊöÇÂÅúÂºÄÂßãÊöÇÂÅú‰∫ÜÂ§ö‰πÖ
        _pausedDuration += [[NSDate date]timeIntervalSinceDate:_pausedTime];
    }
    _pausedTime = nil;
    [_clock start];
    _barrageState = BarrageStart;
    for (GDBarrageElement * element in _preloadedDescriptors) {
        [self receive:element];
    }
}

#pragma mark - ÂºπÂπïÊöÇÂÅú

- (void)pause
{
    // Ê≤°ÊúâËøêË°å, ÂàôÊöÇÂÅúÊó†Êïà
    if (!_startTime) {
        return;
    }
    // ÂΩìÂâçÊ≤°ÊúâÊöÇÂÅú
    if (!_pausedTime) {
        [_clock pause];
        _pausedTime = [NSDate date];
        _barrageState = BarragePause;
    }
    // ÂΩìÂâçÊöÇÂÅú‰∏≠
    else
    {
        _pausedDuration += [[NSDate date]timeIntervalSinceDate:_pausedTime];
        _pausedTime = [NSDate date];
    }
}

#pragma mark - ÂºπÂπïÂÅúÊ≠¢

- (void)stop
{
    _startTime = nil;
    [_clock stop];
    _barrageState = BarrageStop;
}

#pragma mark - Êé•Êî∂ÂºπÂπïÊ∂àÊÅØ, Â¶ÇÊûúÂ∞öÊú™start, ÂàôË∞ÉÁî®Êó†Êïà.

- (void)receive:(GDBarrageElement *)element
{
    
    dispatch_async(_barrageQueue, ^{
        
        if (!_canvas.superview) return; // ÂºπÂπïÂπïÂ∏ÉÊ≤°ÊúâË¢´Âä†ËΩΩ
        if (!_startTime) return; // Â¶ÇÊûúÊ≤°ÊúâÂêØÂä®,ÂàôÊäõÂºÉÊé•Êî∂ÂºπÂπï
        
        element.font = [UIFont systemFontOfSize:_fontSzie];
        
        // ÂØºËà™Â∞±‰ΩçÔºöÂàÜÈÖçËà™ÈÅì...
        GDBarrageTrack * track = [self track_optimal_policy];
        NSLog(@"ÂàÜÈÖçËà™ÈÅì:%li",track.tag);
        
        // Âè∏Êú∫ÂáÜÂ§áÔºöÈ©æÈ©∂Êó∂Èó¥...
        GDBarrageElement * readyElement = [self prepareElement:element inTrack:track];
        
        // ËÆ∞ÂΩïËΩ¶ËæÜÔºöÂÖ•Â∫ìÂ§áÊ°à...
        [self registerElement:element];
        
        dispatch_async(dispatch_get_main_queue(), ^{
            // ÂºÄÂßãÂºÄËΩ¶ÔºöÂè∏Êú∫‰∏äË∑Ø...
            [self beginLaunch:readyElement inTrack:track];
        });
    });
    
}

#pragma mark - Âä†ËΩΩÂºπÂπï

- (void)load:(NSArray<GDBarrageElement> *)elements
{
    // Â¶ÇÊûúÂ∑≤ÁªèÂºÄÂßãÁöÑËØùÂ∞±Áõ¥Êé•Âä†ËΩΩÂºπÂπï
    if (_startTime) {
        for (GDBarrageElement * element in elements) {
            [self receive:element];
        }
    }else{
        _barrageState = BarrageWait;
        if (!_preloadedDescriptors) {
            _preloadedDescriptors = [[NSMutableArray alloc]init];
        }
        for (GDBarrageElement * element in elements) {
            [_preloadedDescriptors addObject:[element copy]];
        }
        [self start];
    }
}

- (void)registerElement:(GDBarrageElement *)element
{
    [_preloadedDescriptors addObject:element];
}

- (GDBarrageElement *)prepareElement:(GDBarrageElement *)element inTrack:(GDBarrageTrack *)track
{
    CGFloat w = element.elementSize.width;
    CGFloat y = track.trackFrame.origin.y;
    CGFloat h = track.trackFrame.size.height;
    CGRect beginFrame = CGRectMake(track.trackFrame.size.width, y, w, h);
    CGRect endFrame = CGRectMake(-w,y, w, h);
    element.appearFrame = beginFrame;
    element.disappearFrame = endFrame;
    return element;
}

- (void)beginLaunch:(GDBarrageElement *)element inTrack:(GDBarrageTrack *)track
{

    __block GDBarrageLable * lable = [[GDBarrageLable alloc] init];
    lable.frame = element.appearFrame;
    lable.font = element.font;
    lable.textColor = element.textColor;
    lable.text = element.text;
    [_canvas addSubview:lable];
    track.lastElement = lable;
    
    __weak typeof(self) weakSelf = self;
    [UIView animateWithDuration:10 delay:0.0f options:UIViewAnimationOptionCurveLinear animations:^{
        lable.frame = element.disappearFrame;
    } completion:^(BOOL finished) {
        track.lastElement = nil;
        [weakSelf removElement:lable];
    }];
    
}

- (void)removElement:(GDBarrageLable *)lable
{
    [lable removeFromSuperview];
    [lable.layer removeFromSuperlayer];
    [lable.layer removeAllAnimations];
    lable = nil;
}

#pragma mark - ÂºπÂπïÊòæÁ§∫ÁöÑËßÜÂõæ

- (UIView *)view
{
    return _canvas;
}

#pragma mark - Ëé∑ÂèñÊöÇÂÅú‰∫ÜÁöÑÊó∂Èó¥

- (NSTimeInterval)pausedDuration
{
    return _pausedDuration + (_pausedTime?[[NSDate date]timeIntervalSinceDate:_pausedTime]:0); // ÂΩìÂâçÂ§Ñ‰∫éÊöÇÂÅúÂΩì‰∏≠
}

#pragma mark - Ëé∑ÂèñÂΩìÂâçÊó∂Èó¥

- (NSTimeInterval)currentTime
{
    NSTimeInterval currentTime = 0.0f;
    {
        currentTime = [[NSDate date]timeIntervalSinceDate:_startTime]-self.pausedDuration;
    }
    return currentTime;
}

@end
